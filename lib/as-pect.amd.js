"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
define("test/IWarning", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("reporter/IWriteable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("util/ILogTarget", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("util/IAspectExports", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("util/ActualValue", ["require", "exports", "util/LogValue"], function (require, exports, LogValue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A class representing a reported expected or actual value. It shares a lot of properties with
     * LogValue, so those are copied over.
     */
    var ActualValue = /** @class */ (function (_super) {
        __extends(ActualValue, _super);
        function ActualValue(wasm, type, value, reference, offset, stack, negated) {
            var _this = _super.call(this, wasm, type, value, reference, offset, stack) || this;
            /**
             * An indicator if the actual expected value is negated.
             */
            _this.negated = false;
            _this.negated = (negated === 1);
            return _this;
        }
        return ActualValue;
    }(LogValue_1.LogValue));
    exports.ActualValue = ActualValue;
});
define("util/LogValue", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A virtual representation of a discrete value logged to from AssemblyScript.
     */
    var LogValue = /** @class */ (function () {
        function LogValue(wasm, type, value, reference, offset, stack) {
            /**
             * If a pointer is referenced, this is the precise memory location of the referenced block of
             * data.
             */
            this.pointer = 0;
            /**
             * If a pointer is referenced and isn't a string, this is the size of the referenced block of
             * data.
             */
            this.offset = 0;
            /**
             * If a pointer is referenced and ins't a string, this is an array of bytes to be logged byt the
             * logger.
             */
            this.bytes = [];
            /**
             * This is a message generated by the TestSuite to be displayed in the logger.
             */
            this.message = "";
            /**
             * This is the relevant stack trace, filtered with the `/wasm/i` regex.
             */
            this.stack = "";
            /**
             * This is the raw logged value.
             */
            this.value = null;
            this.stack = stack;
            if (type === 5 /* Null */) {
                this.message = "null";
                this.value = null;
            }
            else if (type === 1 /* Float */) {
                this.message = value.toString();
                this.value = value;
            }
            else if (type === 2 /* Reference */) {
                this.message = "Reference Value";
                this.pointer = reference;
                this.offset = offset;
                this.bytes = Array.from(wasm.U8.slice(reference, reference + offset));
            }
            else if (type === 7 /* Truthy */) {
                this.message = "Truthy Value";
            }
            else if (type === 6 /* Falsy */) {
                this.message = "Falsy Value";
            }
            else if (type === 8 /* Finite */) {
                this.message = "Finite Value";
            }
            else if (type === 4 /* Array */) {
                this.message = "Array Value";
                this.pointer = reference;
                this.offset = offset;
                this.bytes = wasm.__getArray(reference);
            }
            else if (type === 3 /* String */) {
                this.message = wasm.__getString(reference);
                this.pointer = reference;
                this.offset = offset;
            }
            else if (type === 0 /* None */) {
                this.message = "No Value Was Expected";
            }
        }
        return LogValue;
    }());
    exports.LogValue = LogValue;
});
define("test/PerformanceLimits", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    ;
});
define("test/TestResult", ["require", "exports", "mathjs"], function (require, exports, mathjs_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This is the data class that contains all the data about each `test()` or `it()` function defined
     * in the `AssemblyScript` module.
     */
    var TestResult = /** @class */ (function () {
        function TestResult() {
            /** The actual test's name or description. */
            this.name = "";
            /** The indicator to see if the test passed. */
            this.pass = false;
            /** The time in milliseconds indicating how long the test ran for each run. */
            this.times = [];
            /** The reported actual value description. */
            this.actual = null;
            /** The reported expected value description. */
            this.expected = null;
            /** If the test failed, this is the message describing why the test failed. */
            this.message = "";
            /** A set of strings logged by the test itself. */
            this.logs = [];
            /** The generated stack trace if the test errored. */
            this.stack = null;
            /** This value is set to true if the test is expected to throw. */
            this.negated = false;
            /** This value indicates if performance statistics were collected for this test. */
            this.performance = false;
            /** This value indicates the maximum number of samples to collect. */
            this.maxSamples = 10000 /* MaxSamples */;
            /** This value indicates the maximum test runtime. */
            this.maxRuntime = 5000 /* MaxTestRuntime */;
            /** The number of decimal places used for rounding. */
            this.decimalPlaces = 0 /* MinimumDecimalPlaces */;
            /** This value indicates if an average was calculated. */
            this.hasAverage = false;
            /** This is the average (mean) value. */
            this.average = 0;
            /** This value indicates if a max was calculated. */
            this.hasMax = false;
            /** This is the max time. */
            this.max = 0;
            /** This value indicates if a median value was calculated. */
            this.hasMedian = false;
            /** This is the calculated median time. */
            this.median = 0;
            /** This value indicated if a min value was calculated. */
            this.hasMin = false;
            /** This calculated minimum value of the times collected.. */
            this.min = 0;
            /** This value indicates if a standard deviation value was calculated. */
            this.hasStdDev = false;
            /** The calculated standard deviation of the times collected. */
            this.stdDev = 0;
            /** A boolean indicating if the variance was calcluated. */
            this.hasVariance = false;
            /** The raw variance calculation before rounding was applied. */
            this.rawVariance = 0;
            /** This value indicates the calculated variance used for standard deviation calculations. */
            this.variance = 0;
            /** This is the timestamp for when the test started in milliseconds. */
            this.start = 0;
            /** This is the timestamp for when the test ended in milliseconds. */
            this.end = 0;
            /** This is the run time for the test in milliseconds. */
            this.runTime = 0;
        }
        /**
         * Caclculate the average value of the collected times.
         */
        TestResult.prototype.calculateAverage = function () {
            this.hasAverage = true;
            this.average = Math.round(1000 * mathjs_1.mean(this.times)) / 1000;
        };
        /**
         * Calculate the max time of the collected times.
         */
        TestResult.prototype.calculateMax = function () {
            this.hasMax = true;
            this.max = Math.max.apply(Math, this.times);
        };
        /**
         * Calculate the median value of the collected times.
         */
        TestResult.prototype.calculateMedian = function () {
            this.hasMedian = true;
            this.median = mathjs_1.round(mathjs_1.median(this.times), this.decimalPlaces);
        };
        /**
         * Calculate the min value of the collected times.
         */
        TestResult.prototype.calculateMin = function () {
            this.hasMin = true;
            this.min = Math.min.apply(Math, this.times);
        };
        /**
         * Calculate the standard deviation of the collected times.
         */
        TestResult.prototype.calculateStandardDeviation = function () {
            if (!this.hasVariance) {
                this.calculateVariance();
            }
            this.hasStdDev = true;
            this.stdDev = mathjs_1.round(Math.sqrt(this.rawVariance), this.decimalPlaces);
        };
        /**
         * Calculate the variance.
         */
        TestResult.prototype.calculateVariance = function () {
            if (this.hasVariance)
                return;
            this.hasVariance = true;
            this.rawVariance = mathjs_1.var(this.times, "biased");
            this.variance = mathjs_1.round(this.rawVariance, this.decimalPlaces);
        };
        return TestResult;
    }());
    exports.TestResult = TestResult;
});
define("test/TestGroup", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This test group class is designed with a data oriented layout in mind. Each test property is
     * represented by an array.
     */
    var TestGroup = /** @class */ (function () {
        function TestGroup() {
            this.tests = [];
            this.todos = [];
            this.logs = [];
            this.name = "";
            this.pass = true;
            this.reason = "";
            this.time = 0;
            this.start = 0;
            this.end = 0;
        }
        return TestGroup;
    }());
    exports.TestGroup = TestGroup;
});
define("test/TestReporter", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TestReporter = /** @class */ (function () {
        function TestReporter() {
        }
        return TestReporter;
    }());
    exports.TestReporter = TestReporter;
});
define("util/IPerformanceConfiguration", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createDefaultPerformanceConfiguration() {
        return {
            /** Enable performance statistics gathering. */
            enabled: false,
            /** Set the maximum number of samples to run for each test. */
            maxSamples: 10000,
            /** Set the maximum test run time in milliseconds. */
            maxTestRunTime: 2000,
            /** Set the number of decimal places to round to. */
            roundDecimalPlaces: 3,
            /** Report the median time in the default reporter. */
            reportMedian: true,
            /** Report the average time in milliseconds. */
            reportAverage: true,
            /** Report the standard deviation. */
            reportStandardDeviation: false,
            /** Report the maximum run time in milliseconds. */
            reportMax: false,
            /** Report the minimum run time in milliseconds. */
            reportMin: false,
            /** Report the variance/ */
            reportVariance: false,
        };
    }
    exports.createDefaultPerformanceConfiguration = createDefaultPerformanceConfiguration;
});
define("reporter/EmptyReporter", ["require", "exports", "test/TestReporter"], function (require, exports, TestReporter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EmptyReporter = /** @class */ (function (_super) {
        __extends(EmptyReporter, _super);
        function EmptyReporter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EmptyReporter.prototype.onFinish = function () { };
        EmptyReporter.prototype.onGroupFinish = function () { };
        EmptyReporter.prototype.onGroupStart = function () { };
        EmptyReporter.prototype.onStart = function () { };
        EmptyReporter.prototype.onTestFinish = function () { };
        EmptyReporter.prototype.onTestStart = function () { };
        EmptyReporter.prototype.onTodo = function () { };
        return EmptyReporter;
    }(TestReporter_1.TestReporter));
    exports.EmptyReporter = EmptyReporter;
});
define("util/timeDifference", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeDifference = function (end, start) { return Math.round((end - start) * 1000) / 1000; };
});
define("test/TestContext", ["require", "exports", "util/IPerformanceConfiguration", "reporter/EmptyReporter", "test/TestGroup", "test/TestResult", "util/timeDifference", "perf_hooks", "util/ActualValue"], function (require, exports, IPerformanceConfiguration_1, EmptyReporter_1, TestGroup_1, TestResult_1, timeDifference_1, perf_hooks_1, ActualValue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var wasmFilter = function (input) { return /wasm-function/i.test(input); };
    var TestContext = /** @class */ (function () {
        function TestContext(props) {
            var _this = this;
            this.wasm = null;
            this.reporter = new EmptyReporter_1.EmptyReporter();
            this.time = 0;
            this.pass = true;
            this.errors = [];
            // stdout emulation
            this.stdoutChunks = [];
            this.stdout = typeof process !== "undefined"
                ? process.stdout
                : {
                    write: function (chunk) { return _this.stdoutChunks.push(chunk); }
                };
            // stderr emulation
            this.stderrChunks = [];
            this.stderr = typeof process !== "undefined"
                ? process.stderr
                : {
                    write: function (chunk) { return _this.stderrChunks.push(chunk); }
                };
            this.performanceConfiguration = IPerformanceConfiguration_1.createDefaultPerformanceConfiguration();
            this.testRegex = new RegExp("");
            this.groupRegex = new RegExp("");
            this.fileName = "";
            this.testGroups = [];
            this.currentGroup = null;
            this.currentTest = null;
            this.logTarget = null;
            this.traceMaps = new Map();
            this.stackTraceIndex = 0;
            this.startupTime = 0;
            /* istanbul ignore next */
            if (props) {
                /* istanbul ignore next */
                if (props.reporter)
                    this.reporter = props.reporter;
                /* istanbul ignore next */
                if (props.stdout)
                    this.stdout = props.stdout;
                /* istanbul ignore next */
                if (props.stderr)
                    this.stderr = props.stderr;
                /* istanbul ignore next */
                if (props.performanceConfiguration)
                    Object.assign(this.performanceConfiguration, props.performanceConfiguration);
                /* istanbul ignore next */
                if (props.testRegex)
                    this.testRegex = props.testRegex;
                /* istanbul ignore next */
                if (props.groupRegex)
                    this.groupRegex = props.groupRegex;
                /* istanbul ignore next */
                if (props.fileName)
                    this.fileName = props.fileName;
            }
        }
        /**
         * This method creates a WebAssembly imports object with all the TestContext functions
         * bound to the TestContext.
         *
         * @param {any[]} imports - Every import item specified.
         */
        TestContext.prototype.createImports = function () {
            var _this = this;
            var imports = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                imports[_i] = arguments[_i];
            }
            var result = Object.assign.apply(Object, [{}].concat(imports, [{
                    __aspect: {
                        tryCall: this.tryCall.bind(this),
                        testCanRun: this.testCanRun.bind(this),
                        groupCanRun: this.groupCanRun.bind(this),
                        testStart: this.testStart.bind(this),
                        testFail: this.testFail.bind(this),
                        testPass: this.testPass.bind(this),
                        groupStart: this.groupStart.bind(this),
                        reportTodo: this.reportTodo.bind(this),
                        groupEnd: this.groupEnd.bind(this),
                        now: this.now.bind(this),
                        getLogStackTrace: this.getLogStackTrace.bind(this),
                    },
                }]));
            result.env = result.env || {};
            var previousAbort = (result.env.abort) || (function () { });
            result.env.abort = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                previousAbort.apply(void 0, args);
                // @ts-ignore
                _this.abort.apply(_this, args);
            };
            return result;
        };
        TestContext.prototype.run = function (wasm) {
            // start the timer
            var start = perf_hooks_1.performance.now();
            // initialize wasm property
            this.wasm = wasm;
            // setup performance values
            wasm.__set_performanceEnabled(this.performanceConfiguration.enabled ? 1 : 0);
            wasm.__set_maxSamples(this.performanceConfiguration.maxSamples);
            wasm.__set_maxTestRunTime(this.performanceConfiguration.maxTestRunTime);
            wasm.__set_roundDecimalPlaces(this.performanceConfiguration.roundDecimalPlaces);
            wasm.__set_recordAverage(this.performanceConfiguration.reportAverage ? 1 : 0);
            wasm.__set_recordMedian(this.performanceConfiguration.reportMedian ? 1 : 0);
            wasm.__set_recordStdDev(this.performanceConfiguration.reportStandardDeviation ? 1 : 0);
            wasm.__set_recordMax(this.performanceConfiguration.reportMax ? 1 : 0);
            wasm.__set_recordMin(this.performanceConfiguration.reportMin ? 1 : 0);
            wasm.__set_recordVar(this.performanceConfiguration.reportVariance ? 1 : 0);
            // initialize and perform test collection
            wasm.__init();
            this.startupTime = timeDifference_1.timeDifference(perf_hooks_1.performance.now(), start);
            // report startup
            this.reporter.onStart(this);
            // run the tests
            wasm.__run();
        };
        /**
         * This is a web assembly utility function that wraps a function call in a try catch block to
         * report success or failure.
         *
         * @param {number} pointer - The function pointer to call. It must accept no parameters and return
         * void.
         * @returns {1 | 0} - If the callback was run successfully without error, it returns 1, else it
         * returns 0.
         */
        TestContext.prototype.tryCall = function (pointer) {
            if (pointer === -1)
                return 1;
            try {
                this.wasm.__call(pointer);
                return 1;
            }
            catch (ex) {
                this.currentTest.stack = this.getErrorStackTrace(ex);
                return 0;
            }
        };
        /**
         * This method checks to see if the provided string matches the test regular expression.
         *
         * @param {number} descriptionPointer - The pointer to the test's name.
         * @returns {1 | 0} - The return value is a bool in AssemblyScript.
         */
        TestContext.prototype.testCanRun = function (descriptionPointer) {
            return this.testRegex.test(this.wasm.__getString(descriptionPointer)) ? 1 : 0;
        };
        /**
         * This method checks to see if the provided string matches the group regular expression.
         *
         * @param {number} descriptionPointer - The pointer to the test's name.
         * @returns {1 | 0} - The return value is a bool in AssemblyScript.
         */
        TestContext.prototype.groupCanRun = function (descriptionPointer) {
            return this.groupRegex.test(this.wasm.__getString(descriptionPointer)) ? 1 : 0;
        };
        /**
         * This function overrides the provided AssemblyScript `env.abort()` function to catch abort
         * reasons.
         *
         * @param {number} reasonPointer - This points to the message value that causes the expectation to
         * fail.
         * @param {number} _fileNamePointer - The file name that reported the error. (Ignored)
         * @param {number} _line - The line that reported the error. (Ignored)
         * @param {number} _col - The column that reported the error. (Ignored)
         */
        TestContext.prototype.abort = function (reasonPointer, fileNamePointer, line, col) {
            if (this.currentTest) {
                this.currentTest.message = reasonPointer !== 0 ? this.wasm.__getString(reasonPointer) : "";
            }
            else {
                console.log(this.fileName);
                var reason = reasonPointer !== 0 ? this.wasm.__getString(reasonPointer) : "";
                var fileName = fileNamePointer !== 0 ? this.wasm.__getString(fileNamePointer) : "";
                console.log(reason);
                console.log(fileName + ":" + line + ":" + col);
            }
        };
        /**
         * Gets an error stack trace.
         */
        TestContext.prototype.getErrorStackTrace = function (ex) {
            var stackItems = ex.stack.toString().split("\n");
            return [stackItems[0]].concat(stackItems.slice(1).filter(wasmFilter)).join("\n");
        };
        /**
         * Starts the next group and starts the timer.
         *
         * @param {number} descriptionPointer - The pointer to the name of the group.
         */
        TestContext.prototype.groupStart = function (descriptionPointer) {
            var group = new TestGroup_1.TestGroup();
            group.name = descriptionPointer !== 0
                ? this.wasm.__getString(descriptionPointer)
                : "";
            group.start = perf_hooks_1.performance.now();
            this.currentGroup = group;
            this.logTarget = group;
            this.reporter.onGroupStart(group);
            this.testGroups.push(group);
        };
        /**
         * Starts a new test.
         *
         * @param {number} descriptionPointer - The pointer to the test description.
         */
        TestContext.prototype.testStart = function (descriptionPointer) {
            var test = new TestResult_1.TestResult();
            test.name = descriptionPointer === 0
                ? ""
                : this.wasm.__getString(descriptionPointer);
            this.logTarget = test;
            this.currentTest = test;
            this.currentGroup.tests.push(test);
            this.reporter.onTestStart(this.currentGroup, test);
        };
        /**
         * Reports a todo.
         *
         * @param {number} descriptionPointer - A pointer to the todo description.
         */
        TestContext.prototype.reportTodo = function (descriptionPointer) {
            var description = descriptionPointer !== 0
                ? this.wasm.__getString(descriptionPointer)
                : "";
            this.currentGroup.todos.push(description);
            this.reporter.onTodo(this.currentGroup, description);
        };
        /**
         * This method is linked to web assembly, and will be called when a group has ended. It also
         * stops the timer and calculated the runtime for the group.
         */
        TestContext.prototype.groupEnd = function (pass) {
            var group = this.currentGroup;
            group.end = perf_hooks_1.performance.now();
            group.time = timeDifference_1.timeDifference(group.end, group.start);
            group.pass = !!pass;
            this.reporter.onGroupFinish(group);
            this.currentGroup = null;
            this.logTarget = null;
        };
        /**
         * This linked function returns the current time.
         */
        TestContext.prototype.now = function () {
            return perf_hooks_1.performance.now();
        };
        TestContext.prototype.testFail = function (actualType, actualValue, actualReference, actualOffset, actualStack, expectedType, expectedValue, expectedReference, expectedOffset, expectedStack, negated) {
            var test = this.currentTest;
            test.pass = false;
            test.negated = (negated === 1);
            test.actual = new ActualValue_1.ActualValue(this.wasm, actualType, actualValue, actualReference, actualOffset, this.traceMaps.get(actualStack), 0);
            test.expected = new ActualValue_1.ActualValue(this.wasm, expectedType, expectedValue, expectedReference, expectedOffset, this.traceMaps.get(expectedStack), negated);
            console.log(test.stack);
            this.reporter.onTestFinish(this.currentGroup, test);
        };
        TestContext.prototype.testPass = function (times, performanceEnabled, roundDecimalPlaces, recordAverage, recordMedian, recordMax, recordMin, recordStdDev, recordVariance, negated) {
            var test = this.currentTest;
            test.times = this.wasm.__getArray(times);
            test.negated = (negated === 1);
            test.pass = true;
            if (performanceEnabled === 1) {
                test.performance = true;
                test.decimalPlaces = roundDecimalPlaces;
                if (recordAverage === 1)
                    test.calculateAverage();
                if (recordMedian === 1)
                    test.calculateMedian();
                if (recordMax === 1)
                    test.calculateMax();
                if (recordMin === 1)
                    test.calculateMin();
                if (recordVariance === 1)
                    test.calculateVariance();
                if (recordStdDev === 1)
                    test.calculateStandardDeviation();
            }
            this.reporter.onTestFinish(this.currentGroup, test);
        };
        /**
         * This method creates a stack trace, filters the relevant functions, then returns an index to
         * the stack trace. Since this value is only read outside of Web Assembly when generating host
         * objects, this prevents the need for strings to be passed into and out of Web Assembly.
         */
        TestContext.prototype.getLogStackTrace = function () {
            var trace = new Error("Stack Trace")
                .stack
                .split("\n")
                .filter(wasmFilter)
                .join("\n");
            var nextID = this.stackTraceIndex + 1;
            this.stackTraceIndex = nextID;
            this.traceMaps.set(nextID, trace);
            return nextID;
        };
        return TestContext;
    }());
    exports.TestContext = TestContext;
});
define("reporter/CSVTestReporter", ["require", "exports", "test/TestReporter", "csv-stringify", "fs", "path"], function (require, exports, TestReporter_2, csv_stringify_1, fs_1, path_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    csv_stringify_1 = __importDefault(csv_stringify_1);
    var columns = ["Group", "Name", "Ran", "Pass", "Runtime", "Message", "Actual", "Expected", "Average", "Mean", "Max", "Min", "StdDev", "Variance"];
    var CSVTestReporter = /** @class */ (function (_super) {
        __extends(CSVTestReporter, _super);
        function CSVTestReporter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.output = null;
            _this.fileName = null;
            return _this;
        }
        CSVTestReporter.prototype.onStart = function (suite) {
            this.output = csv_stringify_1.default({ columns: columns });
            var extension = path_1.extname(suite.fileName);
            var dir = path_1.dirname(suite.fileName);
            var base = path_1.basename(suite.fileName, extension);
            var outPath = path_1.join(process.cwd(), dir, base + ".csv");
            this.fileName = fs_1.createWriteStream(outPath, "utf8");
            this.output.pipe(this.fileName);
            this.output.write(columns);
        };
        CSVTestReporter.prototype.onGroupStart = function () { };
        CSVTestReporter.prototype.onGroupFinish = function () { };
        CSVTestReporter.prototype.onFinish = function () {
            this.output.end();
        };
        CSVTestReporter.prototype.onTestStart = function () { };
        CSVTestReporter.prototype.onTestFinish = function (group, result) {
            this.output.write([
                group.name,
                result.name,
                result.pass ? "PASS" : "FAIL",
                result.runTime.toString(),
                result.message,
                result.actual ? result.actual.message : "",
                result.expected ? result.expected.message : "",
                result.hasAverage ? result.average.toString() : "",
                result.hasMedian ? result.median.toString() : "",
                result.hasMax ? result.max.toString() : "",
                result.hasMin ? result.min.toString() : "",
                result.hasStdDev ? result.stdDev.toString() : "",
                result.hasVariance ? result.variance.toString() : ""
            ]);
        };
        CSVTestReporter.prototype.onTodo = function (group, desc) {
            this.output.write([
                group.name,
                "TODO",
                desc,
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
            ]);
        };
        return CSVTestReporter;
    }(TestReporter_2.TestReporter));
    exports.CSVTestReporter = CSVTestReporter;
});
define("reporter/DefaultTestReporter", ["require", "exports", "chalk", "test/TestReporter"], function (require, exports, chalk_1, TestReporter_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    chalk_1 = __importDefault(chalk_1);
    function stringifyActualValue(type, value) {
        if (!value)
            return "";
        var byteString = "";
        if (value.bytes.length > 0) {
            byteString = "\n               " + createReferenceString(value.bytes, value.pointer, value.offset)
                .split("\n")
                .join("\n               ");
        }
        var stackString = "\n           " + value.stack
            .split("\n")
            .join("\n           ");
        return type === 1 /* Expected */
            ? chalk_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["{green ", "}{blue ", "}{yellow ", "}\n"], ["{green ", "}{blue ", "}{yellow ", "}\\n"])), value.message, byteString, stackString) : chalk_1.default(templateObject_2 || (templateObject_2 = __makeTemplateObject(["{red ", "}{blue ", "}{yellow ", "}\n"], ["{red ", "}{blue ", "}{yellow ", "}\\n"])), value.message, byteString, stackString);
    }
    /**
     * This function generates a 2 digit hexadecimal string from the given number.
     *
     * @param {number} value - A number from [0-255].
     * @returns {string} - The hexadecimal string representing the byte
     */
    function hex(value) {
        var result = value.toString(16);
        if (result.length === 1)
            return "0" + result;
        return result;
    }
    /**
     * This function returns a string that formats the bytes into rows of 8 bytes with a space between
     * byte 4 and 5 on each row.
     *
     * @param {number[]} bytes - The byte array
     * @param {number} pointer - The pointer of the reference.
     * @param {number} offset - The offset of the reference.
     */
    function createReferenceString(bytes, pointer, offset) {
        var referenceEnd = pointer + offset;
        // start with a tabbed out string
        var result = "Range: [dec: " + pointer.toString() + "~" + referenceEnd.toString() + "] [hex: 0x" + pointer.toString(16) + "~0x" + referenceEnd.toString(16) + "]";
        result += "\n07 06 05 04   03 02 01 00";
        result += "\n~~~~~~~~~~~~~~~~~~~~~~~~~";
        result += "\n";
        // for each byte
        for (var i = 0; i < offset; i++) {
            // append a byte and an empty space
            result += hex(bytes[i]) + " ";
            if (i % 8 === 7) {
                // every 8 characters add a newline
                result += "\n";
            }
            else if (i % 4 === 3) {
                // every 4 characters add an extra two spaces
                result += "  ";
            }
        }
        // remove leading space
        return result.trimRight();
    }
    var groupLogIndex = new WeakMap();
    var DefaultTestReporter = /** @class */ (function (_super) {
        __extends(DefaultTestReporter, _super);
        function DefaultTestReporter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.stdout = null;
            return _this;
        }
        DefaultTestReporter.prototype.onStart = function (suite) {
            this.stdout = suite.stdout || process.stdout;
        };
        DefaultTestReporter.prototype.onGroupStart = function (group) {
            this.stdout.write(chalk_1.default(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n[Describe]: ", "\n\n"], ["\\n[Describe]: ", "\\n\\n"])), group.name));
            for (var _i = 0, _a = group.logs; _i < _a.length; _i++) {
                var logValue = _a[_i];
                this.onLog(logValue);
            }
            groupLogIndex.set(group, group.logs.length);
        };
        DefaultTestReporter.prototype.onGroupFinish = function (group) {
            var result = group.pass
                ? chalk_1.default(templateObject_4 || (templateObject_4 = __makeTemplateObject(["{green \u2714 PASS}"], ["{green \u2714 PASS}"]))) : chalk_1.default(templateObject_5 || (templateObject_5 = __makeTemplateObject(["{red \u2716 FAIL}"], ["{red \u2716 FAIL}"])));
            var todoCount = group.todos.length;
            var successCount = group.tests.filter(function (e) { return e.pass; }).length;
            var count = group.tests.length;
            for (var _i = 0, _a = group.logs.slice(groupLogIndex.get(group) || 0); _i < _a.length; _i++) {
                var logValue = _a[_i];
                this.onLog(logValue);
            }
            var fail = (count === successCount)
                ? "0 fail"
                : chalk_1.default(templateObject_6 || (templateObject_6 = __makeTemplateObject(["{red ", " fail}"], ["{red ", " fail}"])), (count - successCount).toString());
            var output = chalk_1.default(templateObject_7 || (templateObject_7 = __makeTemplateObject(["\n  [Result]: ", "\n   [Tests]: {green ", " pass}, ", ", ", " total\n    [Todo]: ", " tests\n    [Time]: ", "ms\n"], ["\n  [Result]: ", "\n   [Tests]: {green ", " pass}, ", ", ", " total\n    [Todo]: ", " tests\n    [Time]: ", "ms\n"])), result, successCount.toString(), fail, count.toString(), todoCount.toString(), group.time.toString());
            this.stdout.write(output);
        };
        DefaultTestReporter.prototype.onTestStart = function (_group, _test) { };
        DefaultTestReporter.prototype.onTestFinish = function (_group, test) {
            if (test.pass) {
                this.stdout.write(chalk_1.default(templateObject_8 || (templateObject_8 = __makeTemplateObject([" {green [Success]: \u2714} ", "\n"], [" {green [Success]: \u2714} ", "\\n"])), test.name));
            }
            else {
                this.stdout.write(chalk_1.default(templateObject_9 || (templateObject_9 = __makeTemplateObject(["    {red [Fail]: \u2716} ", "\n"], ["    {red [Fail]: \u2716} ", "\\n"])), test.name));
                if (!test.negated) {
                    this.stdout.write("\n   [Actual]: " + stringifyActualValue(0 /* Actual */, test.actual) + "\n [Expected]: " + stringifyActualValue(1 /* Expected */, test.expected) + "\n");
                }
                if (test.message) {
                    this.stdout.write(chalk_1.default(templateObject_10 || (templateObject_10 = __makeTemplateObject(["  [Message]: {yellow ", "}\n"], ["  [Message]: {yellow ", "}\\n"])), test.message));
                }
                if (test.stack) {
                    this.stdout.write("    [Stack]: " + test.stack.split("\n").join("\n           ") + "\n");
                }
            }
            if (test.performance) {
                this.stdout.write(chalk_1.default(templateObject_11 || (templateObject_11 = __makeTemplateObject([" {yellow [Samples]}: ", " runs\n"], [" {yellow [Samples]}: ", " runs\\n"])), test.times.length.toString()));
                // log statistics
                if (test.hasAverage) {
                    this.stdout.write(chalk_1.default(templateObject_12 || (templateObject_12 = __makeTemplateObject(["    {yellow [Mean]}: ", "ms\n"], ["    {yellow [Mean]}: ", "ms\\n"])), test.average.toString()));
                }
                if (test.hasMedian) {
                    this.stdout.write(chalk_1.default(templateObject_13 || (templateObject_13 = __makeTemplateObject(["  {yellow [Median]}: ", "ms\n"], ["  {yellow [Median]}: ", "ms\\n"])), test.median.toString()));
                }
                if (test.hasVariance) {
                    this.stdout.write(chalk_1.default(templateObject_14 || (templateObject_14 = __makeTemplateObject(["{yellow [Variance]}: ", "ms\n"], ["{yellow [Variance]}: ", "ms\\n"])), test.variance.toString()));
                }
                if (test.hasStdDev) {
                    this.stdout.write(chalk_1.default(templateObject_15 || (templateObject_15 = __makeTemplateObject(["  {yellow [StdDev]}: ", "ms\n"], ["  {yellow [StdDev]}: ", "ms\\n"])), test.stdDev.toString()));
                }
                if (test.hasMax) {
                    this.stdout.write(chalk_1.default(templateObject_16 || (templateObject_16 = __makeTemplateObject(["     {yellow [Max]}: ", "ms\n"], ["     {yellow [Max]}: ", "ms\\n"])), test.max.toString()));
                }
                if (test.hasMin) {
                    this.stdout.write(chalk_1.default(templateObject_17 || (templateObject_17 = __makeTemplateObject(["     {yellow [Min]}: ", "ms\n"], ["     {yellow [Min]}: ", "ms\\n"])), test.min.toString()));
                }
            }
            else {
                // log the log values
                for (var _i = 0, _a = test.logs; _i < _a.length; _i++) {
                    var logValue = _a[_i];
                    this.onLog(logValue);
                }
            }
        };
        DefaultTestReporter.prototype.onFinish = function (suite) {
            if (suite.testGroups.length === 0)
                return;
            var result = suite.pass
                ? chalk_1.default(templateObject_18 || (templateObject_18 = __makeTemplateObject(["{green \u2714 Pass}"], ["{green \u2714 Pass}"]))) : chalk_1.default(templateObject_19 || (templateObject_19 = __makeTemplateObject(["{red \u2716 Fail}"], ["{red \u2716 Fail}"])));
            var count = suite.testGroups
                .map(function (e) { return e.tests.length; })
                .reduce(function (a, b) { return a + b; }, 0);
            var successCount = suite.testGroups
                .map(function (e) { return e.tests.filter(function (f) { return f.pass; }).length; })
                .reduce(function (a, b) { return a + b; }, 0);
            var fail = (count === successCount)
                ? "0 fail"
                : chalk_1.default(templateObject_20 || (templateObject_20 = __makeTemplateObject(["{red ", " fail}"], ["{red ", " fail}"])), (count - successCount).toString());
            this.stdout.write("\n" + "~".repeat(process.stdout.columns - 10) + "\n\n    [File]: " + suite.fileName + "\n  [Groups]: {green " + suite.testGroups.filter(function (e) { return e.pass; }).length.toString() + " pass}, " + suite.testGroups.length.toString() + " total\n  [Result]: " + result + "\n [Summary]: {green " + successCount.toString() + " pass},  " + fail + ", " + count.toString() + " total\n    [Time]: " + suite.time.toString() + "ms\n");
        };
        DefaultTestReporter.prototype.onTodo = function (_group, todo) {
            this.stdout.write(chalk_1.default(templateObject_21 || (templateObject_21 = __makeTemplateObject(["    {yellow [Todo]:} ", "\n"], ["    {yellow [Todo]:} ", "\\n"])), todo));
        };
        /**
         * A custom logger function for the default reporter that writes the log values using `console.log()`
         *
         * @param {LogValue} logValue - A value to be logged to the console
         */
        DefaultTestReporter.prototype.onLog = function (logValue) {
            // create string representations of the pointer
            var pointer = logValue.pointer.toString();
            var hexPointer = logValue.pointer.toString(16);
            // log the log message
            if (logValue.pointer > 0) {
                this.stdout.write(chalk_1.default(templateObject_22 || (templateObject_22 = __makeTemplateObject(["     {yellow [Log]:} Reference at address [", "] [hex: 0x", "] ", "\n"], ["     {yellow [Log]:} Reference at address [", "] [hex: 0x", "] ", "\\n"])), pointer, hexPointer, logValue.message));
            }
            else {
                this.stdout.write(chalk_1.default(templateObject_23 || (templateObject_23 = __makeTemplateObject(["     {yellow [Log]:} ", "\n"], ["     {yellow [Log]:} ", "\\n"])), logValue.message));
            }
            // if there are bytes to show, create a logging representation of the bytes
            if (logValue.bytes.length > 0) {
                var value = createReferenceString(logValue.bytes, logValue.pointer, logValue.offset);
                this.stdout.write(chalk_1.default(templateObject_24 || (templateObject_24 = __makeTemplateObject(["            {blueBright ", "}\n"], ["            {blueBright ", "}\\n"])), value.split("\n").join("\n            ")));
            }
            this.stdout.write(chalk_1.default(templateObject_25 || (templateObject_25 = __makeTemplateObject(["        {yellow ", "}\n\n"], ["        {yellow ", "}\\n\\n"])), logValue.stack.split("\n").join("\n        ")));
        };
        return DefaultTestReporter;
    }(TestReporter_3.TestReporter));
    exports.DefaultTestReporter = DefaultTestReporter;
    var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7, templateObject_8, templateObject_9, templateObject_10, templateObject_11, templateObject_12, templateObject_13, templateObject_14, templateObject_15, templateObject_16, templateObject_17, templateObject_18, templateObject_19, templateObject_20, templateObject_21, templateObject_22, templateObject_23, templateObject_24, templateObject_25;
});
define("reporter/JSONTestReporter", ["require", "exports", "test/TestReporter", "fs", "path"], function (require, exports, TestReporter_4, fs_2, path_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var JSONTestReporter = /** @class */ (function (_super) {
        __extends(JSONTestReporter, _super);
        function JSONTestReporter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.file = null;
            _this.first = true;
            return _this;
        }
        JSONTestReporter.prototype.onStart = function (suite) {
            var extension = path_2.extname(suite.fileName);
            var dir = path_2.dirname(suite.fileName);
            var base = path_2.basename(suite.fileName, extension);
            var outPath = path_2.join(process.cwd(), dir, base + ".json");
            this.file = fs_2.createWriteStream(outPath, "utf8");
            this.file.write("[");
            this.first = true;
        };
        JSONTestReporter.prototype.onGroupStart = function () { };
        JSONTestReporter.prototype.onGroupFinish = function () { };
        JSONTestReporter.prototype.onFinish = function () {
            this.file.end("\n]");
        };
        JSONTestReporter.prototype.onTestStart = function () { };
        JSONTestReporter.prototype.onTestFinish = function (group, result) {
            this.file.write((this.first ? "\n" : ",\n") + JSON.stringify({
                group: group.name,
                name: result.name,
                pass: result.pass,
                runtime: result.runTime,
                message: result.message,
                actual: result.actual ? result.actual.message : null,
                expected: result.expected ? result.expected.message : null,
                average: result.average,
                median: result.median,
                max: result.max,
                min: result.min,
                stdDev: result.stdDev,
                variance: result.variance,
            }));
            this.first = false;
        };
        JSONTestReporter.prototype.onTodo = function (group, desc) {
            this.file.write((this.first ? "\n" : ",\n") + JSON.stringify({
                group: group.name,
                name: "TODO:" + desc,
                ran: false,
                pass: null,
                runtime: 0,
                message: "",
                actual: null,
                expected: null,
                average: 0,
                median: 0,
                max: 0,
                min: 0,
                stdDev: 0,
                variance: 0,
            }));
            this.first = false;
        };
        return JSONTestReporter;
    }(TestReporter_4.TestReporter));
    exports.JSONTestReporter = JSONTestReporter;
});
define("reporter/SummaryTestReporter", ["require", "exports", "test/TestReporter", "chalk"], function (require, exports, TestReporter_5, chalk_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    chalk_2 = __importDefault(chalk_2);
    var SummaryTestReporter = /** @class */ (function (_super) {
        __extends(SummaryTestReporter, _super);
        function SummaryTestReporter() {
            return _super.call(this) || this;
        }
        SummaryTestReporter.prototype.onStart = function () { };
        SummaryTestReporter.prototype.onGroupStart = function () { };
        SummaryTestReporter.prototype.onGroupFinish = function () { };
        SummaryTestReporter.prototype.onTestStart = function () { };
        SummaryTestReporter.prototype.onTestFinish = function () { };
        SummaryTestReporter.prototype.onTodo = function () { };
        SummaryTestReporter.prototype.onFinish = function (suite) {
            var _a, _b;
            var tests = (_a = []).concat.apply(_a, suite.testGroups.map(function (e) { return e.tests; }));
            var todos = (_b = []).concat.apply(_b, suite.testGroups.map(function (e) { return e.todos; })).length;
            var total = tests.length;
            var pass = tests.reduce(function (left, right) { return right.pass ? left + 1 : left; }, 0);
            if (pass === total) {
                suite.stdout.write(chalk_2.default(templateObject_26 || (templateObject_26 = __makeTemplateObject(["{green.bold \u2714 ", "} Pass: ", " / ", " Todo: ", " Time: ", "ms\n"], ["{green.bold \u2714 ", "} Pass: ", " / ", " Todo: ", " Time: ", "ms\\n"])), suite.fileName, pass.toString(), total.toString(), todos.toString(), suite.time.toString()));
            }
            else {
                suite.stdout.write(chalk_2.default(templateObject_27 || (templateObject_27 = __makeTemplateObject(["{red.bold \u274C ", "} Pass: ", " / ", " Todo: ", " Time: ", "ms\n"], ["{red.bold \u274C ", "} Pass: ", " / ", " Todo: ", " Time: ", "ms\\n"])), suite.fileName, pass.toString(), total.toString(), todos.toString(), suite.time.toString()));
                for (var _i = 0, _c = suite.testGroups; _i < _c.length; _i++) {
                    var group = _c[_i];
                    if (group.pass)
                        continue;
                    suite.stdout.write(chalk_2.default(templateObject_28 || (templateObject_28 = __makeTemplateObject(["  ", "\n"], ["  ", "\\n"])), group.name));
                    inner: for (var _d = 0, _e = group.tests; _d < _e.length; _d++) {
                        var test_1 = _e[_d];
                        if (test_1.pass)
                            continue inner;
                        suite.stdout.write(chalk_2.default(templateObject_29 || (templateObject_29 = __makeTemplateObject(["    {red.bold \u274C ", "} - ", "\n"], ["    {red.bold \u274C ", "} - ", "\\n"])), test_1.name, test_1.message));
                        if (test_1.expected !== null)
                            suite.stdout.write(chalk_2.default(templateObject_30 || (templateObject_30 = __makeTemplateObject(["      {green.bold [Expected]:} ", "\n"], ["      {green.bold [Expected]:} ", "\\n"])), test_1.expected.message));
                        if (test_1.actual !== null)
                            suite.stdout.write(chalk_2.default(templateObject_31 || (templateObject_31 = __makeTemplateObject(["      {red.bold [Actual]  :} ", "\n"], ["      {red.bold [Actual]  :} ", "\\n"])), test_1.actual.message));
                    }
                }
            }
        };
        return SummaryTestReporter;
    }(TestReporter_5.TestReporter));
    exports.SummaryTestReporter = SummaryTestReporter;
    var templateObject_26, templateObject_27, templateObject_28, templateObject_29, templateObject_30, templateObject_31;
});
define("util/IConfiguration", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("cli/types", ["require", "exports", "chalk", "fs"], function (require, exports, chalk_3, fs_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    chalk_3 = __importDefault(chalk_3);
    fs_3 = __importDefault(fs_3);
    function types(assemblyFolder, testFolder, typesFile, typesFileSource) {
        console.log("");
        console.log(chalk_3.default(templateObject_32 || (templateObject_32 = __makeTemplateObject(["[Log] Initializing types."], ["[Log] Initializing types."]))));
        console.log("");
        // Create the assembly folder if it doesn't exist
        if (!fs_3.default.existsSync(assemblyFolder)) {
            console.log(chalk_3.default(templateObject_33 || (templateObject_33 = __makeTemplateObject(["[Log] Creating folder: ./assembly/"], ["[Log] Creating folder: ./assembly/"]))));
            fs_3.default.mkdirSync(assemblyFolder);
        }
        // Create the test folder if it doesn't exist
        if (!fs_3.default.existsSync(testFolder)) {
            console.log(chalk_3.default(templateObject_34 || (templateObject_34 = __makeTemplateObject(["[Log] Creating folder: ./assembly/__tests__/"], ["[Log] Creating folder: ./assembly/__tests__/"]))));
            fs_3.default.mkdirSync(testFolder);
        }
        // Create the types file if it doesn't exist
        if (!fs_3.default.existsSync(typesFile)) {
            console.log(chalk_3.default(templateObject_35 || (templateObject_35 = __makeTemplateObject(["[Log] Creating file: assembly/__tests__/as-pect.d.ts"], ["[Log] Creating file: assembly/__tests__/as-pect.d.ts"]))));
            fs_3.default.createReadStream(typesFileSource, "utf-8")
                .pipe(fs_3.default.createWriteStream(typesFile, "utf-8"));
        }
    }
    exports.types = types;
    var templateObject_32, templateObject_33, templateObject_34, templateObject_35;
});
define("cli/init", ["require", "exports", "chalk", "path", "fs"], function (require, exports, chalk_4, path_3, fs_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    chalk_4 = __importDefault(chalk_4);
    path_3 = __importDefault(path_3);
    fs_4 = __importDefault(fs_4);
    function init(assemblyFolder, testFolder, typesFile, typesFileSource) {
        console.log("");
        console.log(chalk_4.default(templateObject_36 || (templateObject_36 = __makeTemplateObject(["[Log] Initializing test suite files."], ["[Log] Initializing test suite files."]))));
        console.log("");
        // create the assembly folder if it doesn't exist
        if (!fs_4.default.existsSync(assemblyFolder)) {
            console.log(chalk_4.default(templateObject_37 || (templateObject_37 = __makeTemplateObject(["[Log] Creating folder: ./assembly/"], ["[Log] Creating folder: ./assembly/"]))));
            fs_4.default.mkdirSync(assemblyFolder);
        }
        // Create the test folder if it doesn't exist
        if (!fs_4.default.existsSync(testFolder)) {
            console.log(chalk_4.default(templateObject_38 || (templateObject_38 = __makeTemplateObject(["[Log] Creating folder: ./assembly/__tests__/"], ["[Log] Creating folder: ./assembly/__tests__/"]))));
            fs_4.default.mkdirSync(testFolder);
            // create the example file only if the __tests__ folder does not exist
            var exampleFile = path_3.default.join(testFolder, "example.spec.ts");
            var exampleFileSource = path_3.default.join(__dirname, "../../init/example.spec.ts");
            if (!fs_4.default.existsSync(exampleFile)) {
                console.log(chalk_4.default(templateObject_39 || (templateObject_39 = __makeTemplateObject(["[Log] Creating file: ./assembly/__tests__/example.spec.ts"], ["[Log] Creating file: ./assembly/__tests__/example.spec.ts"]))));
                fs_4.default.createReadStream(exampleFileSource, "utf-8")
                    .pipe(fs_4.default.createWriteStream(exampleFile, "utf-8"));
            }
        }
        // create the types file if it doesn't exist for typescript tooling users
        if (!fs_4.default.existsSync(typesFile)) {
            console.log(chalk_4.default(templateObject_40 || (templateObject_40 = __makeTemplateObject(["[Log] Creating file: assembly/__tests__/as-pect.d.ts"], ["[Log] Creating file: assembly/__tests__/as-pect.d.ts"]))));
            fs_4.default.createReadStream(typesFileSource, "utf-8")
                .pipe(fs_4.default.createWriteStream(typesFile, "utf-8"));
        }
        // create the default configuration file
        var configFile = path_3.default.join(process.cwd(), "as-pect.config.js");
        var configFileSource = path_3.default.join(__dirname, "../../init/as-pect.config.js");
        if (!fs_4.default.existsSync(configFile)) {
            console.log(chalk_4.default(templateObject_41 || (templateObject_41 = __makeTemplateObject(["[Log] Creating file: as-pect.config.js"], ["[Log] Creating file: as-pect.config.js"]))));
            fs_4.default.createReadStream(configFileSource, "utf-8")
                .pipe(fs_4.default.createWriteStream(configFile, "utf-8"));
        }
    }
    exports.init = init;
    var templateObject_36, templateObject_37, templateObject_38, templateObject_39, templateObject_40, templateObject_41;
});
define("cli/help", ["require", "exports", "chalk"], function (require, exports, chalk_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    chalk_5 = __importDefault(chalk_5);
    function help() {
        console.log(chalk_5.default(templateObject_42 || (templateObject_42 = __makeTemplateObject(["\n  {bold.blueBright SYNTAX}\n    {bold.green asp} --init                          Create a test config, an assembly/__tests__ folder and exit.\n    {bold.green asp} -i\n    {bold.green asp} --config=as-pect.config.js      Use a specified configuration\n    {bold.green asp} -c as-pect.config.js\n    {bold.green asp} --version                       View the version.\n    {bold.green asp} -v\n    {bold.green asp} --help                          Show this help screen.\n    {bold.green asp} -h\n    {bold.green asp} --types                         Copy the types file to assembly/__tests__/as-pect.d.ts\n    {bold.green asp} -t\n\n  {bold.blueBright TEST OPTIONS}\n    {bold.green --file=[regex]}                       Run the tests of each file that matches this regex. {yellow (Default: /./)}\n      {bold.green --files=[regex]}\n      {bold.green -f=[regex]}\n\n    {bold.green --group=[regex]}                      Run each describe block that matches this regex {yellow (Default: /(:?)/)}\n      {bold.green --groups=[regex]}\n      {bold.green -g=[regex]}\n\n    {bold.green --test=[regex]}                       Run each test that matches this regex {yellow (Default: /(:?)/)}\n      {bold.green --tests=[regex]}\n      {bold.green -t=[regex]}\n\n    {bold.green --output-binary}                      Create a (.wasm) file can contains all the tests to be run later.\n      {bold.green -o}\n\n    {bold.green --norun}                              Skip running tests and output the compiler files.\n      {bold.green -n}\n\n    {bold.green --reporter}                           Define the reporter to be used. {yellow (Default: DefaultTestReporter)}\n      {bold.green --reporter=SummaryTestReporter}     Use the summary reporter.\n      {bold.green --reporter=DefaultTestReporter}     Use the default test reporter.\n      {bold.green --reporter=JSONTestReporter}        Use the JSON reporter (output results to json files.)\n      {bold.green --reporter=CSVTestReporter}         Use the empty reporter (output results to csv files.)\n      {bold.green --reporter=EmptyReporter}           Use the empty reporter. {yellow (This reporter reports nothing)}\n      {bold.green --reporter=./path/to/reporter.js}   Use the default exported object from this module as the reporter.\n\n  {bold.blueBright PERFORMANCE OPTIONS}\n    {bold.green --performance}                        Enable performance statistics for {bold every} test. {yellow (Default: false)}\n    {bold.green --max-samples=[number]}               Set the maximum number of samples to run for each test. {yellow (Default: 10000 samples)}\n    {bold.green --max-test-run-time=[number]}         Set the maximum test run time in milliseconds. {yellow (Default: 2000ms)}\n    {bold.green --round-decimal-places=[number]}      Set the number of decimal places to round to. {yellow (Default: 3)}\n    {bold.green --report-median(=false)?}             Enable/Disable reporting of the median time. {yellow (Default: true)}\n    {bold.green --report-average(=false)?}            Enable/Disable reporting of the average time. {yellow (Default: true)}\n    {bold.green --report-standard-deviation(=false)?} Enable/Disable reporting of the standard deviation. {yellow (Default: false)}\n    {bold.green --report-max(=false)?}                Enable/Disable reporting of the largest run time. {yellow (Default: false)}\n    {bold.green --report-min(=false)?}                Enable/Disable reporting of the smallest run time. {yellow (Default: false)}\n    {bold.green --report-variance(=false)?}           Enable/Disable reporting of the variance. {yellow (Default: false)}\n  "], ["\n  {bold.blueBright SYNTAX}\n    {bold.green asp} --init                          Create a test config, an assembly/__tests__ folder and exit.\n    {bold.green asp} -i\n    {bold.green asp} --config=as-pect.config.js      Use a specified configuration\n    {bold.green asp} -c as-pect.config.js\n    {bold.green asp} --version                       View the version.\n    {bold.green asp} -v\n    {bold.green asp} --help                          Show this help screen.\n    {bold.green asp} -h\n    {bold.green asp} --types                         Copy the types file to assembly/__tests__/as-pect.d.ts\n    {bold.green asp} -t\n\n  {bold.blueBright TEST OPTIONS}\n    {bold.green --file=[regex]}                       Run the tests of each file that matches this regex. {yellow (Default: /./)}\n      {bold.green --files=[regex]}\n      {bold.green -f=[regex]}\n\n    {bold.green --group=[regex]}                      Run each describe block that matches this regex {yellow (Default: /(:?)/)}\n      {bold.green --groups=[regex]}\n      {bold.green -g=[regex]}\n\n    {bold.green --test=[regex]}                       Run each test that matches this regex {yellow (Default: /(:?)/)}\n      {bold.green --tests=[regex]}\n      {bold.green -t=[regex]}\n\n    {bold.green --output-binary}                      Create a (.wasm) file can contains all the tests to be run later.\n      {bold.green -o}\n\n    {bold.green --norun}                              Skip running tests and output the compiler files.\n      {bold.green -n}\n\n    {bold.green --reporter}                           Define the reporter to be used. {yellow (Default: DefaultTestReporter)}\n      {bold.green --reporter=SummaryTestReporter}     Use the summary reporter.\n      {bold.green --reporter=DefaultTestReporter}     Use the default test reporter.\n      {bold.green --reporter=JSONTestReporter}        Use the JSON reporter (output results to json files.)\n      {bold.green --reporter=CSVTestReporter}         Use the empty reporter (output results to csv files.)\n      {bold.green --reporter=EmptyReporter}           Use the empty reporter. {yellow (This reporter reports nothing)}\n      {bold.green --reporter=./path/to/reporter.js}   Use the default exported object from this module as the reporter.\n\n  {bold.blueBright PERFORMANCE OPTIONS}\n    {bold.green --performance}                        Enable performance statistics for {bold every} test. {yellow (Default: false)}\n    {bold.green --max-samples=[number]}               Set the maximum number of samples to run for each test. {yellow (Default: 10000 samples)}\n    {bold.green --max-test-run-time=[number]}         Set the maximum test run time in milliseconds. {yellow (Default: 2000ms)}\n    {bold.green --round-decimal-places=[number]}      Set the number of decimal places to round to. {yellow (Default: 3)}\n    {bold.green --report-median(=false)?}             Enable/Disable reporting of the median time. {yellow (Default: true)}\n    {bold.green --report-average(=false)?}            Enable/Disable reporting of the average time. {yellow (Default: true)}\n    {bold.green --report-standard-deviation(=false)?} Enable/Disable reporting of the standard deviation. {yellow (Default: false)}\n    {bold.green --report-max(=false)?}                Enable/Disable reporting of the largest run time. {yellow (Default: false)}\n    {bold.green --report-min(=false)?}                Enable/Disable reporting of the smallest run time. {yellow (Default: false)}\n    {bold.green --report-variance(=false)?}           Enable/Disable reporting of the variance. {yellow (Default: false)}\n  "]))));
    }
    exports.help = help;
    var templateObject_42;
});
define("cli/util/IYargs", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("cli/util/collectPerformanceConfiguration", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function collectPerformanceConfiguration(yargs, performanceConfiguration) {
        if (yargs.argv.hasOwnProperty("performance"))
            performanceConfiguration.enabled = yargs.argv.performance !== "false";
        // gather all the flags
        if (yargs.argv.hasOwnProperty("maxSamples"))
            performanceConfiguration.maxSamples = parseFloat(yargs.argv.maxSamples.toString());
        if (yargs.argv.hasOwnProperty("maxTestRunTime"))
            performanceConfiguration.maxTestRunTime = parseFloat(yargs.argv.maxTestRunTime.toString());
        if (yargs.argv.hasOwnProperty("maxTestRunTime"))
            performanceConfiguration.maxTestRunTime = parseFloat(yargs.argv.maxTestRunTime.toString());
        if (yargs.argv.hasOwnProperty("roundDecimalPlaces"))
            performanceConfiguration.roundDecimalPlaces = parseFloat(yargs.argv.roundDecimalPlaces.toString());
        if (yargs.argv.hasOwnProperty("reportMedian"))
            performanceConfiguration.reportMedian = yargs.argv.reportMedian !== "false";
        if (yargs.argv.hasOwnProperty("reportAverage"))
            performanceConfiguration.reportAverage = yargs.argv.reportAverage !== "false";
        if (yargs.argv.hasOwnProperty("reportStandardDeviation"))
            performanceConfiguration.reportStandardDeviation = yargs.argv.reportStandardDeviation !== "false";
        if (yargs.argv.hasOwnProperty("reportMax"))
            performanceConfiguration.reportMax = yargs.argv.reportMax !== "false";
        if (yargs.argv.hasOwnProperty("reportMin"))
            performanceConfiguration.reportMin = yargs.argv.reportMin !== "false";
        if (yargs.argv.hasOwnProperty("reportVariance"))
            performanceConfiguration.reportVariance = yargs.argv.reportVariance !== "false";
    }
    exports.collectPerformanceConfiguration = collectPerformanceConfiguration;
});
define("cli/util/collectReporter", ["require", "exports", "reporter/DefaultTestReporter", "reporter/EmptyReporter", "reporter/SummaryTestReporter", "path", "reporter/CSVTestReporter", "reporter/JSONTestReporter"], function (require, exports, DefaultTestReporter_1, EmptyReporter_2, SummaryTestReporter_1, path_4, CSVTestReporter_1, JSONTestReporter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    path_4 = __importDefault(path_4);
    function collectReporter(yargs) {
        var targetReporter = yargs.argv.reporter || yargs.argv.r;
        // get relative reporters
        if (targetReporter.startsWith(".")) {
            try {
                var result = require(path_4.default.join(process.cwd(), targetReporter));
                // if something is returned
                if (result) {
                    if (typeof result === "function") { // instantiate it if it's a default exported class
                        return new result();
                    }
                    if (typeof result.default === "function") {
                        return new result.default();
                    }
                    else {
                        return result.default || result;
                    }
                }
                else {
                    return new DefaultTestReporter_1.DefaultTestReporter();
                }
            }
            catch (ex) {
                console.error("Cannot find target reporter at", path_4.default.join(process.cwd(), targetReporter));
                console.error(ex);
                process.exit(1);
                // @ts-ignore: the process has exited
                return null;
            }
        }
        else if (targetReporter === "EmptyReporter") {
            return new EmptyReporter_2.EmptyReporter();
        }
        else if (targetReporter === "SummaryTestReporter") {
            return new SummaryTestReporter_1.SummaryTestReporter();
        }
        else if (targetReporter === "CSVTestReporter") {
            return new CSVTestReporter_1.CSVTestReporter();
        }
        else if (targetReporter === "JSONTestReporter") {
            return new JSONTestReporter_1.JSONTestReporter();
        }
        else {
            return new DefaultTestReporter_1.DefaultTestReporter();
        }
    }
    exports.collectReporter = collectReporter;
});
define("cli/util/getTestEntryFiles", ["require", "exports", "glob"], function (require, exports, glob_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    glob_1 = __importDefault(glob_1);
    function getTestEntryFiles(yargs, include, disclude) {
        var testEntryFiles = new Set();
        var fileRegexArg = yargs.argv.file || yargs.argv.f || ".*";
        var fileRegex = new RegExp(fileRegexArg);
        // for each pattern to be included
        for (var _i = 0, include_1 = include; _i < include_1.length; _i++) {
            var pattern = include_1[_i];
            // push all the resulting files so that each file gets tested individually
            entry: for (var _a = 0, _b = glob_1.default.sync(pattern); _a < _b.length; _a++) {
                var entry = _b[_a];
                // test for discludes
                for (var _c = 0, disclude_1 = disclude; _c < disclude_1.length; _c++) {
                    var test_2 = disclude_1[_c];
                    if (test_2.test(entry))
                        continue entry;
                }
                // if the fileRegex matches the test, add it to the entry file Set
                if (fileRegex.test(entry))
                    testEntryFiles.add(entry);
            }
        }
        return testEntryFiles;
    }
    exports.getTestEntryFiles = getTestEntryFiles;
});
define("cli/util/writeFile", ["require", "exports", "fs"], function (require, exports, fs_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    fs_5 = __importDefault(fs_5);
    function writeFile(file, contents) {
        return new Promise(function (resolve, reject) {
            fs_5.default.writeFile(file, contents, function (err) {
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
    }
    exports.writeFile = writeFile;
});
define("cli/run", ["require", "exports", "assemblyscript/dist/asc", "test/TestContext", "fs", "assemblyscript/lib/loader", "reporter/DefaultTestReporter", "perf_hooks", "util/timeDifference", "util/IPerformanceConfiguration", "path", "chalk", "glob", "cli/util/collectPerformanceConfiguration", "cli/util/collectReporter", "cli/util/getTestEntryFiles", "cli/util/writeFile"], function (require, exports, asc_1, TestContext_1, fs, loader_1, DefaultTestReporter_2, perf_hooks_2, timeDifference_2, IPerformanceConfiguration_2, path, chalk_6, glob_2, collectPerformanceConfiguration_1, collectReporter_1, getTestEntryFiles_1, writeFile_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    asc_1 = __importDefault(asc_1);
    fs = __importStar(fs);
    path = __importStar(path);
    chalk_6 = __importDefault(chalk_6);
    glob_2 = __importDefault(glob_2);
    //@ts-ignore
    var parse = require("assemblyscript/cli/util/options").parse;
    var options = require("assemblyscript/cli/util/options").options;
    function run(yargs, compilerArgs) {
        var start = perf_hooks_2.performance.now();
        // obtain the configuration file
        var configurationPath = path.resolve(process.cwd(), yargs.argv.c || yargs.argv.config || "./as-pect.config.js");
        console.log(chalk_6.default(templateObject_43 || (templateObject_43 = __makeTemplateObject(["{bgWhite.black [Log]} Using configuration ", ""], ["{bgWhite.black [Log]} Using configuration ", ""])), configurationPath));
        var configuration = {};
        try {
            configuration = require(configurationPath) || {};
        }
        catch (ex) {
            console.error("");
            console.error(chalk_6.default(templateObject_44 || (templateObject_44 = __makeTemplateObject(["{bgRedBright.black [Error]} There was a problem loading {bold [", "]}."], ["{bgRedBright.black [Error]} There was a problem loading {bold [", "]}."])), configurationPath));
            console.error(ex);
            process.exit(1);
        }
        // configuration must be an object
        if (!configuration) {
            console.error(chalk_6.default(templateObject_45 || (templateObject_45 = __makeTemplateObject(["{bgRedBright.black [Error]} Configuration at {bold [", "]} is null or not an object."], ["{bgRedBright.black [Error]} Configuration at {bold [", "]} is null or not an object."])), configurationPath));
            process.exit(1);
        }
        var include = configuration.include || ["assembly/__tests__/**/*.spec.ts"];
        var add = configuration.add || ["assembly/__tests__/**/*.include.ts"];
        // parse passed cli compiler arguments and let them override defaults.
        var _a = compilerArgs.length > 0 ? parse(compilerArgs, asc_1.default.options) : { options: {}, unknown: [] }, ascOptions = _a.options, unknown = _a.unknown;
        if (unknown.length > 0) {
            console.error(chalk_6.default(templateObject_46 || (templateObject_46 = __makeTemplateObject(["{bgRedBright.black [Error]} Unknown compiler arguments {bold [", "]}."], ["{bgRedBright.black [Error]} Unknown compiler arguments {bold [", "]}."])), unknown.join(", ")));
            process.exit(1);
        }
        var flags = Object.assign(ascOptions, configuration.flags, {
            "--validate": [],
            "--debug": [],
            /** This is required. Do not change this. */
            "--binaryFile": ["output.wasm"],
        });
        var disclude = configuration.disclude || [];
        // if a reporter is specified in cli arguments, override configuration
        var reporter = (yargs.argv.reporter || yargs.argv.r)
            ? collectReporter_1.collectReporter(yargs)
            : configuration.reporter || new DefaultTestReporter_2.DefaultTestReporter();
        var performanceConfiguration = configuration.performance || IPerformanceConfiguration_2.createDefaultPerformanceConfiguration();
        // setup performance options, overriding configured values if the flag is passed to the cli
        collectPerformanceConfiguration_1.collectPerformanceConfiguration(yargs, performanceConfiguration);
        // include all the file globs
        console.log(chalk_6.default(templateObject_47 || (templateObject_47 = __makeTemplateObject(["{bgWhite.black [Log]} Including files: ", ""], ["{bgWhite.black [Log]} Including files: ", ""])), include.join(", ")));
        // Create the test and group matchers
        if (!configuration.testRegex) {
            var testRegex = new RegExp(yargs.argv.tests || yargs.argv.test || yargs.argv.t || ".*", "i");
            configuration.testRegex = testRegex;
            console.log(chalk_6.default(templateObject_48 || (templateObject_48 = __makeTemplateObject(["{bgWhite.black [Log]} Running tests that match: ", ""], ["{bgWhite.black [Log]} Running tests that match: ", ""])), testRegex.source));
        }
        if (!configuration.groupRegex) {
            var groupRegex = new RegExp(yargs.argv.groups || yargs.argv.group || yargs.argv.g || ".*", "i");
            configuration.groupRegex = groupRegex;
            console.log(chalk_6.default(templateObject_49 || (templateObject_49 = __makeTemplateObject(["{bgWhite.black [Log]} Running groups that match: ", ""], ["{bgWhite.black [Log]} Running groups that match: ", ""])), groupRegex.source));
        }
        /**
         * Check to see if the binary files should be written to the fileSystem.
         */
        var outputBinary = !!(yargs.argv.outputBinary || yargs.argv.o || configuration.outputBinary);
        if (outputBinary) {
            console.log(chalk_6.default(templateObject_50 || (templateObject_50 = __makeTemplateObject(["{bgWhite.black [Log]} Outputing Binary *.wasm files."], ["{bgWhite.black [Log]} Outputing Binary *.wasm files."]))));
        }
        /**
         * Check to see if the tests should be run in the first place.
         */
        var runTests = !(yargs.argv.norun || yargs.argv.n);
        if (!runTests) {
            console.log(chalk_6.default(templateObject_51 || (templateObject_51 = __makeTemplateObject(["{bgWhite.black [Log]} Not running tests, only outputting files."], ["{bgWhite.black [Log]} Not running tests, only outputting files."]))));
        }
        if (compilerArgs.length > 0) {
            console.log(chalk_6.default(templateObject_52 || (templateObject_52 = __makeTemplateObject(["{bgWhite.black [Log]} Adding compiler arguments: "], ["{bgWhite.black [Log]} Adding compiler arguments: "]))) + compilerArgs.join(" "));
        }
        // add a line seperator between the next line and this line
        console.log("");
        var addedTestEntryFiles = new Set();
        /** Get all the test entry files. */
        var testEntryFiles = getTestEntryFiles_1.getTestEntryFiles(yargs, include, disclude);
        for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {
            var pattern = add_1[_i];
            // push all the added files to the added entry point list
            for (var _b = 0, _c = glob_2.default.sync(pattern); _b < _c.length; _b++) {
                var entry = _c[_b];
                addedTestEntryFiles.add(entry);
            }
        }
        // loop over each file and create a binary, index it on binaries
        var binaries = {};
        // must include the assembly/index.ts file located in the package
        var entryPath = path.join(__dirname, "../../assembly/index.ts");
        var relativeEntryPath = path.relative(process.cwd(), entryPath);
        // add the relativeEntryPath of as-pect to the list of compiled files for each test
        addedTestEntryFiles.add(relativeEntryPath);
        // Create a test runner, and run each test
        var count = testEntryFiles.size;
        // create the array of compiler flags from the flags object
        var flagList = Object.entries(flags).reduce(function (args, _a) {
            var flag = _a[0], options = _a[1];
            return args.concat(flag, options);
        }, []);
        var testCount = 0;
        var successCount = 0;
        var groupSuccessCount = 0;
        var groupCount = 0;
        var errors = [];
        var filePromises = [];
        var failed = false;
        var folderMap = new Map();
        var fileMap = new Map();
        // for each file, synchronously run each test
        Array.from(testEntryFiles).forEach(function (file, i) {
            asc_1.default.main([file].concat(Array.from(addedTestEntryFiles), flagList), {
                stdout: process.stdout,
                stderr: process.stderr,
                listFiles: function (dirname, baseDir) {
                    var folder = path.join(baseDir, dirname);
                    if (folderMap.has(folder)) {
                        return folderMap.get(folder);
                    }
                    try {
                        var results = fs.readdirSync(folder).filter(function (file) { return /^(?!.*\.d\.ts$).*\.ts$/.test(file); });
                        folderMap.set(folder, results);
                        return results;
                    }
                    catch (e) {
                        return [];
                    }
                },
                readFile: function (filename, baseDir) {
                    var fileName = path.join(baseDir, filename);
                    if (fileMap.has(fileName)) {
                        return fileMap.get(fileName);
                    }
                    try {
                        var contents = fs.readFileSync(fileName, { encoding: "utf8" });
                        fileMap.set(fileName, contents);
                        return contents;
                    }
                    catch (e) {
                        return null;
                    }
                },
                writeFile: function (name, contents) {
                    var ext = path.extname(name);
                    // get the wasm file
                    if (ext === ".wasm") {
                        binaries[i] = contents;
                        if (!outputBinary)
                            return;
                    }
                    var outfileName = path.join(path.dirname(file), path.basename(file, path.extname(file)) + ext);
                    filePromises.push(writeFile_1.writeFile(outfileName, contents));
                }
            }, function (error) {
                // if there are any compilation errors, stop the test suite
                if (error) {
                    console.error("There was a compilation error when trying to create the wasm binary for file: " + file + ".");
                    console.error(error);
                    return process.exit(1);
                }
                // if the binary wasn't emitted, stop the test suite
                if (!binaries[i]) {
                    console.error("There was no output binary file: " + file + ". Did you forget to emit the binary?");
                    return process.exit(1);
                }
                if (runTests) {
                    // create a test runner
                    var runner = new TestContext_1.TestContext({
                        fileName: file,
                        groupRegex: configuration.groupRegex,
                        testRegex: configuration.testRegex,
                        performanceConfiguration: performanceConfiguration,
                        reporter: reporter,
                    });
                    // detect custom imports
                    var customImportFileLocation = path.resolve(path.join(path.dirname(file), path.basename(file, path.extname(file)) + ".imports.js"));
                    var imports = runner.createImports((fs.existsSync(customImportFileLocation)
                        ? require(customImportFileLocation)
                        : configuration.imports) || {});
                    // instantiate the module
                    var wasm = loader_1.instantiateBuffer(binaries[i], imports);
                    if (runner.errors.length > 0) {
                        errors.push.apply(errors, runner.errors);
                    }
                    else {
                        // call run buffer because it's already compiled
                        runner.run(wasm);
                        testCount += runner.testGroups.reduce(function (left, right) { return left + right.tests.length; }, 0);
                        successCount += runner.testGroups
                            .reduce(function (left, right) { return left + right.tests.filter(function (e) { return e.pass; }).length; }, 0);
                        groupCount += runner.testGroups.length;
                        groupSuccessCount = runner.testGroups.reduce(function (left, right) { return left + (right.pass ? 1 : 0); }, groupSuccessCount);
                    }
                }
                count -= 1;
                // if any tests failed, and they all ran, exit(1)
                if (count === 0) {
                    if (runTests) {
                        var end = perf_hooks_2.performance.now();
                        failed = testCount !== successCount || errors.length > 0;
                        var result = failed
                            ? chalk_6.default(templateObject_53 || (templateObject_53 = __makeTemplateObject(["{red \u2716 FAIL}"], ["{red \u2716 FAIL}"]))) : chalk_6.default(templateObject_54 || (templateObject_54 = __makeTemplateObject(["{green \u2714 PASS}"], ["{green \u2714 PASS}"])));
                        console.log("~".repeat(process.stdout.columns - 10));
                        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
                            var error_1 = errors_1[_i];
                            console.log(chalk_6.default(templateObject_55 || (templateObject_55 = __makeTemplateObject(["\n   [Error]: {red ", "}: ", "\n   [Stack]: {yellow ", "}\n  "], ["\n   [Error]: {red ", "}: ", "\n   [Stack]: {yellow ", "}\n  "])), error_1.type, error_1.message, error_1.stackTrace.split("\n").join("\n            ")));
                        }
                        console.log("\n  [Result]: " + result + "\n   [Files]: " + testEntryFiles.size + " total\n  [Groups]: " + groupCount + " count, " + groupSuccessCount + " pass\n   [Tests]: " + successCount.toString() + " pass, " + (testCount - successCount).toString() + " fail, " + testCount.toString() + " total\n    [Time]: " + timeDifference_2.timeDifference(end, start).toString() + "ms");
                    }
                    Promise.all(filePromises).then(function () {
                        if (failed)
                            process.exit(1);
                    });
                }
                return 0;
            });
        });
    }
    exports.run = run;
    var templateObject_43, templateObject_44, templateObject_45, templateObject_46, templateObject_47, templateObject_48, templateObject_49, templateObject_50, templateObject_51, templateObject_52, templateObject_53, templateObject_54, templateObject_55;
});
define("cli/index", ["require", "exports", "chalk", "path", "yargs-parser", "cli/types", "cli/init", "cli/help", "cli/run"], function (require, exports, chalk_7, path_5, yargs_parser_1, types_1, init_1, help_1, run_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    chalk_7 = __importDefault(chalk_7);
    path_5 = __importDefault(path_5);
    yargs_parser_1 = __importDefault(yargs_parser_1);
    var pkg = require("../../package.json");
    /**
     * This is the cli entry point and expects an array of arguments from the command line.
     *
     * @param {string[]} args - The arguments from the command line
     */
    function asp(args) {
        var hasCompilerArgs = args.includes("--");
        var aspectArgs = hasCompilerArgs
            ? args.slice(0, args.indexOf("--"))
            : args;
        var compilerArgs = hasCompilerArgs
            ? args.slice(args.indexOf("--") + 1)
            : [];
        // parse the arguments
        var yargs = {
            argv: yargs_parser_1.default(aspectArgs),
        };
        // Skip ascii art if asked for the version
        if (!(yargs.argv.v || yargs.argv.version)) {
            console.log(chalk_7.default(templateObject_56 || (templateObject_56 = __makeTemplateObject(["{bold.bgWhite.black ", "       ___   _____                       __    \n      /   | / ___/      ____  ___  _____/ /_   \n     / /| | \\__ \\______/ __ \\/ _ \\/ ___/ __/   \n    / ___ |___/ /_____/ /_/ /  __/ /__/ /_     \n   /_/  |_/____/     / .___/\\___/\\___/\\__/     \n                    /_/                        }\n\n  \u26A1AS-pect\u26A1 Test suite runner {bgGreenBright.black [", "]}\n  "], ["{bold.bgWhite.black ",
                "       ___   _____                       __    \n      /   | / ___/      ____  ___  _____/ /_   \n     / /| | \\\\__ \\\\______/ __ \\\\/ _ \\\\/ ___/ __/   \n    / ___ |___/ /_____/ /_/ /  __/ /__/ /_     \n   /_/  |_/____/     / .___/\\\\___/\\\\___/\\\\__/     \n                    /_/                        }\n\n  \u26A1AS-pect\u26A1 Test suite runner {bgGreenBright.black [", "]}\n  "])), "", pkg.version));
        }
        var assemblyFolder = path_5.default.join(process.cwd(), "assembly");
        var testFolder = path_5.default.join(assemblyFolder, "__tests__");
        var typesFileSource = path_5.default.join(__dirname, "../../assembly/__tests__/as-pect.d.ts");
        var typesFile = path_5.default.join(testFolder, "as-pect.d.ts");
        if (yargs.argv.t || yargs.argv.types) {
            types_1.types(assemblyFolder, testFolder, typesFile, typesFileSource);
        }
        else if (yargs.argv.i || yargs.argv.init) {
            // init script
            init_1.init(assemblyFolder, testFolder, typesFile, typesFileSource);
        }
        else if (yargs.argv.v || yargs.argv.version) { // display the version
            console.log(pkg.version);
        }
        else if (yargs.argv.help || yargs.argv.h) { // display the help file
            help_1.help();
        }
        else { // run the compiler and test suite
            run_1.run(yargs, compilerArgs);
        }
    }
    exports.asp = asp;
    var templateObject_56;
});
define("as-pect", ["require", "exports", "test/TestContext", "test/TestGroup", "test/TestReporter", "test/TestResult", "reporter/CSVTestReporter", "reporter/DefaultTestReporter", "reporter/EmptyReporter", "reporter/JSONTestReporter", "reporter/SummaryTestReporter", "util/ActualValue", "util/IPerformanceConfiguration", "util/LogValue", "cli/index"], function (require, exports, TestContext_2, TestGroup_2, TestReporter_6, TestResult_2, CSVTestReporter_2, DefaultTestReporter_3, EmptyReporter_3, JSONTestReporter_2, SummaryTestReporter_2, ActualValue_2, IPerformanceConfiguration_3, LogValue_2, cli_1) {
    "use strict";
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(TestContext_2);
    __export(TestGroup_2);
    __export(TestReporter_6);
    __export(TestResult_2);
    __export(CSVTestReporter_2);
    __export(DefaultTestReporter_3);
    __export(EmptyReporter_3);
    __export(JSONTestReporter_2);
    __export(SummaryTestReporter_2);
    __export(ActualValue_2);
    __export(IPerformanceConfiguration_3);
    __export(LogValue_2);
    __export(cli_1);
});
require("../lib/cli/index.js").asp(process.argv.slice(2));
//# sourceMappingURL=as-pect.amd.js.map