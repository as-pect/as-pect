/// <reference types="node" />
/// <reference types="yargs-parser" />
declare module "test/IWarning" {
    export interface IWarning {
        type: string;
        message: string;
        stackTrace: string;
    }
}
declare module "reporter/IWriteable" {
    export interface IWritable {
        write(chunk: string): void;
    }
}
declare module "util/ILogTarget" {
    import { LogValue } from "util/LogValue";
    export interface ILogTarget {
        logs: LogValue[];
    }
}
declare module "util/IAspectExports" {
    export interface IAspectExports {
        __call(pointer: number): void;
        __init(): void;
        __run(): void;
        __set_performanceEnabled(value: 1 | 0): void;
        __set_maxSamples(value: number): void;
        __set_maxTestRunTime(value: number): void;
        __set_roundDecimalPlaces(value: number): void;
        __set_recordAverage(value: 1 | 0): void;
        __set_recordMedian(value: 1 | 0): void;
        __set_recordStdDev(value: 1 | 0): void;
        __set_recordMax(value: 1 | 0): void;
        __set_recordMin(value: 1 | 0): void;
        __set_recordVar(value: 1 | 0): void;
    }
}
declare module "util/ActualValue" {
    import { LogValue } from "util/LogValue";
    import { ASUtil } from "assemblyscript/lib/loader";
    import { IAspectExports } from "util/IAspectExports";
    /**
     * All the value types.
     */
    export const enum ValueType {
        None = 0,
        Float = 1,
        Reference = 2,
        String = 3,
        Array = 4,
        Null = 5,
        Falsy = 6,
        Truthy = 7,
        Finite = 8
    }
    /**
     * A class representing a reported expected or actual value. It shares a lot of properties with
     * LogValue, so those are copied over.
     */
    export class ActualValue extends LogValue {
        constructor(wasm: ASUtil & IAspectExports, type: ValueType, value: number, reference: number, offset: number, stack: string, negated: 0 | 1);
        /**
         * An indicator if the actual expected value is negated.
         */
        negated: boolean;
    }
}
declare module "util/LogValue" {
    import { ValueType } from "util/ActualValue";
    import { ASUtil } from "assemblyscript/lib/loader";
    import { IAspectExports } from "util/IAspectExports";
    /**
     * A virtual representation of a discrete value logged to from AssemblyScript.
     */
    export class LogValue {
        constructor(wasm: ASUtil & IAspectExports, type: ValueType, value: number, reference: number, offset: number, stack: string);
        /**
         * If a pointer is referenced, this is the precise memory location of the referenced block of
         * data.
         */
        pointer: number;
        /**
         * If a pointer is referenced and isn't a string, this is the size of the referenced block of
         * data.
         */
        offset: number;
        /**
         * If a pointer is referenced and ins't a string, this is an array of bytes to be logged byt the
         * logger.
         */
        bytes: number[];
        /**
         * This is a message generated by the TestSuite to be displayed in the logger.
         */
        message: string;
        /**
         * This is the relevant stack trace, filtered with the `/wasm/i` regex.
         */
        stack: string;
        /**
         * This is the raw logged value.
         */
        value: number | null;
    }
}
declare module "test/PerformanceLimits" {
    export const enum PerformanceLimits {
        MaxSamples = 10000,
        MaxTestRuntime = 5000,
        MinimumDecimalPlaces = 0
    }
}
declare module "test/TestResult" {
    import { LogValue } from "util/LogValue";
    import { ActualValue } from "util/ActualValue";
    import { ILogTarget } from "util/ILogTarget";
    /**
     * This is the data class that contains all the data about each `test()` or `it()` function defined
     * in the `AssemblyScript` module.
     */
    export class TestResult implements ILogTarget {
        /** The actual test's name or description. */
        name: string;
        /** The indicator to see if the test passed. */
        pass: boolean;
        /** The time in milliseconds indicating how long the test ran for each run. */
        times: number[];
        /** The reported actual value description. */
        actual: ActualValue | null;
        /** The reported expected value description. */
        expected: ActualValue | null;
        /** If the test failed, this is the message describing why the test failed. */
        message: string;
        /** A set of strings logged by the test itself. */
        logs: LogValue[];
        /** The generated stack trace if the test errored. */
        stack: string | null;
        /** This value is set to true if the test is expected to throw. */
        negated: boolean;
        /** This value indicates if performance statistics were collected for this test. */
        performance: boolean;
        /** This value indicates the maximum number of samples to collect. */
        maxSamples: number;
        /** This value indicates the maximum test runtime. */
        maxRuntime: number;
        /** The number of decimal places used for rounding. */
        decimalPlaces: number;
        /** This value indicates if an average was calculated. */
        hasAverage: boolean;
        /** This is the average (mean) value. */
        average: number;
        /** This value indicates if a max was calculated. */
        hasMax: boolean;
        /** This is the max time. */
        max: number;
        /** This value indicates if a median value was calculated. */
        hasMedian: boolean;
        /** This is the calculated median time. */
        median: number;
        /** This value indicated if a min value was calculated. */
        hasMin: boolean;
        /** This calculated minimum value of the times collected.. */
        min: number;
        /** This value indicates if a standard deviation value was calculated. */
        hasStdDev: boolean;
        /** The calculated standard deviation of the times collected. */
        stdDev: number;
        /** A boolean indicating if the variance was calcluated. */
        hasVariance: boolean;
        /** The raw variance calculation before rounding was applied. */
        rawVariance: number;
        /** This value indicates the calculated variance used for standard deviation calculations. */
        variance: number;
        /** This is the timestamp for when the test started in milliseconds. */
        start: number;
        /** This is the timestamp for when the test ended in milliseconds. */
        end: number;
        /** This is the run time for the test in milliseconds. */
        runTime: number;
        /**
         * Caclculate the average value of the collected times.
         */
        calculateAverage(): void;
        /**
         * Calculate the max time of the collected times.
         */
        calculateMax(): void;
        /**
         * Calculate the median value of the collected times.
         */
        calculateMedian(): void;
        /**
         * Calculate the min value of the collected times.
         */
        calculateMin(): void;
        /**
         * Calculate the standard deviation of the collected times.
         */
        calculateStandardDeviation(): void;
        /**
         * Calculate the variance.
         */
        calculateVariance(): void;
    }
}
declare module "test/TestGroup" {
    import { LogValue } from "util/LogValue";
    import { ILogTarget } from "util/ILogTarget";
    import { TestResult } from "test/TestResult";
    /**
     * This test group class is designed with a data oriented layout in mind. Each test property is
     * represented by an array.
     */
    export class TestGroup implements ILogTarget {
        tests: TestResult[];
        todos: string[];
        logs: LogValue[];
        name: string;
        pass: boolean;
        reason: string;
        time: number;
        start: number;
        end: number;
    }
}
declare module "test/TestReporter" {
    import { TestContext } from "test/TestContext";
    import { TestGroup } from "test/TestGroup";
    import { TestResult } from "test/TestResult";
    export abstract class TestReporter {
        /**
         * A function that is called when a test suite starts.
         *
         * @param {TestSuite} suite - The started test suite.
         */
        abstract onStart(suite: TestContext): void;
        /**
         * A function that is called when a test group starts.
         *
         * @param {TestGroup} group - The started test group.
         */
        abstract onGroupStart(group: TestGroup): void;
        /**
         * A function that is called when a test group ends.
         *
         * @param {TestGroup} group - The ended test group.
         */
        abstract onGroupFinish(group: TestGroup): void;
        /**
         * A function that is called when a test starts.
         *
         * @param {TestGroup} group - The current test group.
         * @param {TestResult} result - The generated test result reference that will be used for the test.
         */
        abstract onTestStart(group: TestGroup, result: TestResult): void;
        /**
         * A function that is called when a test ends.
         *
         * @param {TestGroup} group - The current test group.
         * @param {TestResult} result - The generated test result reference.
         */
        abstract onTestFinish(group: TestGroup, result: TestResult): void;
        /**
         * A function that is called when a test suite ends.
         *
         * @param {TestSuite} suite - The ended test suite.
         */
        abstract onFinish(suite: TestContext): void;
        /**
         * A function that is called when a test group reports a "todo" item.
         *
         * @param {TestGroup} group - The current test group.
         * @param {string} todo - The todo description.
         */
        abstract onTodo(group: TestGroup, todo: string): void;
    }
}
declare module "util/IPerformanceConfiguration" {
    /**
     * This is the interface for performance configuration provided to the TestContext object, before
     * tests are run.
     */
    export interface IPerformanceConfiguration {
        /** Enable performance statistics gathering. */
        enabled?: boolean;
        /** Set the minimum number of samples to run for each test in milliseconds. */
        maxSamples?: number;
        /** Set the maximum test run time in milliseconds. */
        maxTestRunTime?: number;
        /** Report the median time in the default reporter. */
        reportMedian?: boolean;
        /** Report the average time in milliseconds. */
        reportAverage?: boolean;
        /** Report the standard deviation. */
        reportStandardDeviation?: boolean;
        /** Report the maximum run time in milliseconds. */
        reportMax?: boolean;
        /** Report the minimum run time in milliseconds. */
        reportMin?: boolean;
        /** Report the variance. */
        reportVariance?: boolean;
        /** Set the number of decimal places to round to. */
        roundDecimalPlaces?: number;
    }
    export function createDefaultPerformanceConfiguration(): IPerformanceConfiguration;
}
declare module "reporter/EmptyReporter" {
    import { TestReporter } from "test/TestReporter";
    export class EmptyReporter extends TestReporter {
        onFinish(): void;
        onGroupFinish(): void;
        onGroupStart(): void;
        onStart(): void;
        onTestFinish(): void;
        onTestStart(): void;
        onTodo(): void;
    }
}
declare module "util/timeDifference" {
    export const timeDifference: (end: number, start: number) => number;
}
declare module "test/TestContext" {
    import { IWritable } from "reporter/IWriteable";
    import { TestReporter } from "test/TestReporter";
    import { IPerformanceConfiguration } from "util/IPerformanceConfiguration";
    import { ASUtil } from "assemblyscript/lib/loader";
    import { IAspectExports } from "util/IAspectExports";
    import { TestGroup } from "test/TestGroup";
    import { IWarning } from "test/IWarning";
    export interface ITestContextParameters {
        reporter?: TestReporter;
        stdout?: IWritable;
        stderr?: IWritable;
        performanceConfiguration?: IPerformanceConfiguration;
        testRegex?: RegExp;
        groupRegex?: RegExp;
        fileName?: string;
    }
    export class TestContext {
        private wasm;
        reporter: TestReporter;
        time: number;
        pass: boolean;
        errors: IWarning[];
        stdoutChunks: string[];
        stdout: IWritable;
        stderrChunks: string[];
        stderr: IWritable;
        performanceConfiguration: IPerformanceConfiguration;
        testRegex: RegExp;
        groupRegex: RegExp;
        fileName: string;
        testGroups: TestGroup[];
        private currentGroup;
        private currentTest;
        private logTarget;
        private traceMaps;
        private stackTraceIndex;
        startupTime: number;
        constructor(props: ITestContextParameters);
        /**
         * This method creates a WebAssembly imports object with all the TestContext functions
         * bound to the TestContext.
         *
         * @param {any[]} imports - Every import item specified.
         */
        createImports(...imports: any[]): any;
        run(wasm: ASUtil & IAspectExports): void;
        /**
         * This is a web assembly utility function that wraps a function call in a try catch block to
         * report success or failure.
         *
         * @param {number} pointer - The function pointer to call. It must accept no parameters and return
         * void.
         * @returns {1 | 0} - If the callback was run successfully without error, it returns 1, else it
         * returns 0.
         */
        private tryCall;
        /**
         * This method checks to see if the provided string matches the test regular expression.
         *
         * @param {number} descriptionPointer - The pointer to the test's name.
         * @returns {1 | 0} - The return value is a bool in AssemblyScript.
         */
        private testCanRun;
        /**
         * This method checks to see if the provided string matches the group regular expression.
         *
         * @param {number} descriptionPointer - The pointer to the test's name.
         * @returns {1 | 0} - The return value is a bool in AssemblyScript.
         */
        private groupCanRun;
        /**
         * This function overrides the provided AssemblyScript `env.abort()` function to catch abort
         * reasons.
         *
         * @param {number} reasonPointer - This points to the message value that causes the expectation to
         * fail.
         * @param {number} _fileNamePointer - The file name that reported the error. (Ignored)
         * @param {number} _line - The line that reported the error. (Ignored)
         * @param {number} _col - The column that reported the error. (Ignored)
         */
        private abort;
        /**
         * Gets an error stack trace.
         */
        private getErrorStackTrace;
        /**
         * Starts the next group and starts the timer.
         *
         * @param {number} descriptionPointer - The pointer to the name of the group.
         */
        private groupStart;
        /**
         * Starts a new test.
         *
         * @param {number} descriptionPointer - The pointer to the test description.
         */
        testStart(descriptionPointer: number): void;
        /**
         * Reports a todo.
         *
         * @param {number} descriptionPointer - A pointer to the todo description.
         */
        private reportTodo;
        /**
         * This method is linked to web assembly, and will be called when a group has ended. It also
         * stops the timer and calculated the runtime for the group.
         */
        private groupEnd;
        /**
         * This linked function returns the current time.
         */
        private now;
        private testFail;
        testPass(timesPointer: number, performanceEnabled: 0 | 1, roundDecimalPlaces: 0 | 1, recordAverage: 0 | 1, recordMedian: 0 | 1, recordMax: 0 | 1, recordMin: 0 | 1, recordStdDev: 0 | 1, recordVariance: 0 | 1, negated: 0 | 1): void;
        /**
         * This method creates a stack trace, filters the relevant functions, then returns an index to
         * the stack trace. Since this value is only read outside of Web Assembly when generating host
         * objects, this prevents the need for strings to be passed into and out of Web Assembly.
         */
        private getLogStackTrace;
    }
}
declare module "reporter/CSVTestReporter" {
    import { TestReporter } from "test/TestReporter";
    import { TestContext } from "test/TestContext";
    import { Stringifier } from "csv-stringify";
    import { WriteStream } from "fs";
    import { TestGroup } from "test/TestGroup";
    import { TestResult } from "test/TestResult";
    export class CSVTestReporter extends TestReporter {
        protected output: Stringifier | null;
        protected fileName: WriteStream | null;
        onStart(suite: TestContext): void;
        onGroupStart(): void;
        onGroupFinish(): void;
        onFinish(): void;
        onTestStart(): void;
        onTestFinish(group: TestGroup, result: TestResult): void;
        onTodo(group: TestGroup, desc: string): void;
    }
}
declare module "reporter/DefaultTestReporter" {
    import { TestGroup } from "test/TestGroup";
    import { TestResult } from "test/TestResult";
    import { TestContext } from "test/TestContext";
    import { LogValue } from "util/LogValue";
    import { TestReporter } from "test/TestReporter";
    import { IWritable } from "reporter/IWriteable";
    export class DefaultTestReporter extends TestReporter {
        protected stdout: IWritable | null;
        onStart(suite: TestContext): void;
        onGroupStart(group: TestGroup): void;
        onGroupFinish(group: TestGroup): void;
        onTestStart(_group: TestGroup, _test: TestResult): void;
        onTestFinish(_group: TestGroup, test: TestResult): void;
        onFinish(suite: TestContext): void;
        onTodo(_group: TestGroup, todo: string): void;
        /**
         * A custom logger function for the default reporter that writes the log values using `console.log()`
         *
         * @param {LogValue} logValue - A value to be logged to the console
         */
        onLog(logValue: LogValue): void;
    }
}
declare module "reporter/JSONTestReporter" {
    import { TestReporter } from "test/TestReporter";
    import { TestContext } from "test/TestContext";
    import { WriteStream } from "fs";
    import { TestGroup } from "test/TestGroup";
    import { TestResult } from "test/TestResult";
    export class JSONTestReporter extends TestReporter {
        protected file: WriteStream | null;
        private first;
        onStart(suite: TestContext): void;
        onGroupStart(): void;
        onGroupFinish(): void;
        onFinish(): void;
        onTestStart(): void;
        onTestFinish(group: TestGroup, result: TestResult): void;
        onTodo(group: TestGroup, desc: string): void;
    }
}
declare module "reporter/SummaryTestReporter" {
    import { TestReporter } from "test/TestReporter";
    import { TestContext } from "test/TestContext";
    export class SummaryTestReporter extends TestReporter {
        onStart(): void;
        onGroupStart(): void;
        onGroupFinish(): void;
        onTestStart(): void;
        onTestFinish(): void;
        onTodo(): void;
        constructor();
        onFinish(suite: TestContext): void;
    }
}
declare module "util/IConfiguration" {
    import { TestReporter } from "test/TestReporter";
    import { IPerformanceConfiguration } from "util/IPerformanceConfiguration";
    export interface ICompilerFlags {
        [flag: string]: string[];
    }
    export interface IConfiguration {
        /**
         * A string of globs to find the files that will be included in the test suite.
         */
        include?: string[];
        /**
         * A set of globs passed to the glob package that quality files to be added to each test.
         */
        add?: string[];
        /**
         * All the compiler flags needed for this test suite. Make sure that a binary file is output.
         */
        flags?: ICompilerFlags;
        /**
         * And array of regular expressions that are tested against the file names. If they match, the
         * files will be discluded.
         */
        disclude?: RegExp[];
        /**
         * If the test module requires a set of imports to be loaded, it can be set here.
         */
        imports?: any;
        /**
         * Set the default performance measurement values.
         */
        performance?: IPerformanceConfiguration;
        /**
         * A custom reporter that extends the `TestReporter` class, and is responsible for generating log
         * output.
         */
        reporter?: TestReporter;
        /**
         * A regular expression that instructs the TestContext to only run tests that match this regex.
         */
        testRegex?: RegExp;
        /**
         * A regular expression that instructs the TestContext to only run groups that match this regex.
         */
        groupRegex?: RegExp;
        /**
         * Specifies if a wasm binary should be output. Default is false.
         */
        outputBinary?: boolean;
    }
}
declare module "cli/types" {
    export function types(assemblyFolder: string, testFolder: string, typesFile: string, typesFileSource: string): void;
}
declare module "cli/init" {
    export function init(assemblyFolder: string, testFolder: string, typesFile: string, typesFileSource: string): void;
}
declare module "cli/help" {
    export function help(): void;
}
declare module "cli/util/IYargs" {
    import yargsparser from "yargs-parser";
    export interface IYargs {
        argv: yargsparser.Arguments;
    }
}
declare module "cli/util/collectPerformanceConfiguration" {
    import { IYargs } from "cli/util/IYargs";
    import { IPerformanceConfiguration } from "util/IPerformanceConfiguration";
    export function collectPerformanceConfiguration(yargs: IYargs, performanceConfiguration: IPerformanceConfiguration): void;
}
declare module "cli/util/collectReporter" {
    import { TestReporter } from "test/TestReporter";
    import { IYargs } from "cli/util/IYargs";
    export function collectReporter(yargs: IYargs): TestReporter;
}
declare module "cli/util/getTestEntryFiles" {
    import { IYargs } from "cli/util/IYargs";
    export function getTestEntryFiles(yargs: IYargs, include: string[], disclude: RegExp[]): Set<string>;
}
declare module "cli/util/writeFile" {
    export function writeFile(file: string, contents: Uint8Array): Promise<void>;
}
declare module "cli/run" {
    import { IYargs } from "cli/util/IYargs";
    export function run(yargs: IYargs, compilerArgs: string[]): void;
}
declare module "cli/index" {
    /**
     * This is the cli entry point and expects an array of arguments from the command line.
     *
     * @param {string[]} args - The arguments from the command line
     */
    export function asp(args: string[]): void;
}
declare module "as-pect" {
    export * from "test/IWarning";
    export * from "test/TestContext";
    export * from "test/TestGroup";
    export * from "test/TestReporter";
    export * from "test/TestResult";
    export * from "reporter/CSVTestReporter";
    export * from "reporter/DefaultTestReporter";
    export * from "reporter/EmptyReporter";
    export * from "reporter/JSONTestReporter";
    export * from "reporter/SummaryTestReporter";
    export * from "util/ActualValue";
    export * from "util/IAspectExports";
    export * from "util/IConfiguration";
    export * from "util/ILogTarget";
    export * from "util/IPerformanceConfiguration";
    export * from "util/LogValue";
    export * from "cli/index";
}
//# sourceMappingURL=as-pect.amd.d.ts.map